# -*- coding: utf-8 -*-
"""DB Index CODE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xj9rh9wA6W5j4EQzhyYvwowG_ZDoU8Ok
"""

import numpy as np
import pandas as pd

INPUT_PATH = "DB_INDEX.xlsx"
SHEET_NAME = "US INDEX"          # Note: in your file it is uppercase
OUTPUT_PATH = "DB_INDEX_US_EQW_INDEX.xlsx"

DATE_COL = "DATE"

def zscore(series: pd.Series, ddof: int = 0) -> pd.Series:
    """
    Standardise a series to z-scores: (x - mean) / std.
    ddof=0 uses population std; ddof=1 uses sample std.
    """
    s = pd.to_numeric(series, errors="coerce")
    mu = s.mean(skipna=True)
    sigma = s.std(skipna=True, ddof=ddof)
    if sigma == 0 or np.isnan(sigma):
        # If a column is constant or empty, z-score is undefined; return 0s
        return pd.Series(0.0, index=series.index)
    return (s - mu) / sigma

# -----------------------------
# Load data
# -----------------------------
df = pd.read_excel(INPUT_PATH, sheet_name=SHEET_NAME)

# Ensure DATE is datetime
df[DATE_COL] = pd.to_datetime(df[DATE_COL], errors="coerce")

# Identify factor columns (the 5 variables)
factor_cols = [c for c in df.columns if c != DATE_COL]

# Coerce factors to numeric (handles stray text/blank cells safely)
df[factor_cols] = df[factor_cols].apply(pd.to_numeric, errors="coerce")

# Optional: handle missing data before standardising
# Common approach for market series is forward-fill then back-fill.
df[factor_cols] = df[factor_cols].ffill().bfill()

# -----------------------------
# Standardise factors (z-scores)
# -----------------------------
z_cols = []
for c in factor_cols:
    zc = f"{c} (z)"
    df[zc] = zscore(df[c], ddof=0)
    z_cols.append(zc)

# -----------------------------
# Equal-weight composite index
# -----------------------------
# Equal weights => average of the 5 z-score series
df["US_Factors_EQW_Z"] = df[z_cols].mean(axis=1)

# Optional: rebase to 100 for easier charting/interpretation
# Rebase using the earliest available date observation
df_sorted = df.sort_values(DATE_COL).copy()
base_value = df_sorted["US_Factors_EQW_Z"].iloc[0]
df["US_Factors_EQW_Rebased_100"] = 100.0 + (df["US_Factors_EQW_Z"] - base_value)

# (Optional) If you want a strictly positive index that behaves more like a price series,
# you could also turn z-scores into a cumulative return proxy, but thatâ€™s a different design choice.

# -----------------------------
# Save output
# -----------------------------
with pd.ExcelWriter(OUTPUT_PATH, engine="openpyxl") as writer:
    df.to_excel(writer, sheet_name="US_INDEX_EQW_OUTPUT", index=False)

print(f"Done. Wrote output to: {OUTPUT_PATH}")
print("Composite columns created: US_Factors_EQW_Z, US_Factors_EQW_Rebased_100")

import numpy as np
import pandas as pd

INPUT_PATH = "DB_INDEX.xlsx"
SHEET_NAME = "China INDEX"
OUTPUT_PATH = "DB_INDEX_CHINA_EQW_INDEX.xlsx"

DATE_COL = "Date (HK)"

def zscore(series: pd.Series, ddof: int = 0) -> pd.Series:
    """
    Standardise a series to z-scores: (x - mean) / std.
    ddof=0 uses population std; ddof=1 uses sample std.
    """
    s = pd.to_numeric(series, errors="coerce")
    mu = s.mean(skipna=True)
    sigma = s.std(skipna=True, ddof=ddof)
    if sigma == 0 or np.isnan(sigma):
        # If a column is constant or empty, z-score is undefined; return 0s
        return pd.Series(0.0, index=series.index)
    return (s - mu) / sigma

# -----------------------------
# Load CHINA INDEX sheet
# -----------------------------
df = pd.read_excel(INPUT_PATH, sheet_name=SHEET_NAME)

# Ensure DATE is datetime
df[DATE_COL] = pd.to_datetime(df[DATE_COL], errors="coerce")

# Identify factor columns (the 2 variables) = everything except DATE
factor_cols = [c for c in df.columns if c != DATE_COL]
if len(factor_cols) != 2:
    print(f"Warning: expected 2 factor columns, found {len(factor_cols)}: {factor_cols}")

# Coerce factors to numeric safely
df[factor_cols] = df[factor_cols].apply(pd.to_numeric, errors="coerce")

# Handle missing values (forward-fill then back-fill is common for daily macro/market series)
df[factor_cols] = df[factor_cols].ffill().bfill()

# -----------------------------
# Standardise (z-scores)
# -----------------------------
z_cols = []
for c in factor_cols:
    zc = f"{c} (z)"
    df[zc] = zscore(df[c], ddof=0)
    z_cols.append(zc)

# -----------------------------
# Equal-weight China composite index
# -----------------------------
df["China_Factors_EQW_Z"] = df[z_cols].mean(axis=1)

# Optional: rebase to 100 for readability
df_sorted = df.sort_values(DATE_COL).copy()
base_value = df_sorted["China_Factors_EQW_Z"].iloc[0]
df["China_Factors_EQW_Rebased_100"] = 100.0 + (df["China_Factors_EQW_Z"] - base_value)

# -----------------------------
# Save output
# -----------------------------
with pd.ExcelWriter(OUTPUT_PATH, engine="openpyxl") as writer:
    df.to_excel(writer, sheet_name="CHINA_INDEX_EQW_OUTPUT", index=False)

print(f"Done. Wrote output to: {OUTPUT_PATH}")
print("Composite columns created: China_Factors_EQW_Z, China_Factors_EQW_Rebased_100")